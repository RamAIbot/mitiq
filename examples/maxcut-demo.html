<!-- This file displays the animated SVG link to the GitHub repository 
in the top right corner -->


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solving MaxCut with Mitiq-improved QAOA &#8212; Mitiq 0.17.0dev documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/styles/pydata-sphinx-theme.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Defining Hamiltonians as Linear Combinations of Pauli Strings" href="hamiltonians.html" />
    <link rel="prev" title="Mitigating the energy landscape of a variational circuit with Mitiq" href="simple_landscape.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/mitiq-logo.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../readme.html">
  <a href="https://github.com/unitaryfund/mitiq">
  </a>
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../guide/guide.html">
  Users Guide
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../apidoc.html">
  API-doc
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../toc_contributing.html">
  Contributing
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../changelog.html">
  Changelog
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../zz_bibliography.html">
  References
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="braket_mirror_circuit.html">
   Mirror circuit benchmark improved with zero-noise extrapolation on AWS Braket
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ibmq-backends.html">
   Zero-noise extrapolation on IBMQ backends
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="pyquil_demo.html">
   Zero-noise extrapolation on PyQuil parametric programs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="vqe-pyquil-demo.html">
   Variational quantum eigensolver improved with zero-noise extrapolation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="simple_landscape.html">
   Variational circuit mitigation with zero-noise extrapolation
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   MaxCut benchmark with zero-noise extrapolation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hamiltonians.html">
   Defining a Mitiq executor with a hamiltonian
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mitiq-paper/mitiq-paper-codeblocks.html">
   Mitiq paper codeblocks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="molecular_hydrogen.html">
   Estimating the potential energy surface of molecular Hydrogen with ZNE
  </a>
 </li>
</ul>

  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-maxcut-problem">
   The MaxCut problem
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#representing-a-solution-as-bitstring">
     Representing a solution as bitstring
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#embedding-a-maxcut-problem-into-a-physical-hamiltonian">
   Embedding a MaxCut problem into a physical Hamiltonian
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#define-the-qaoa-cost-hamiltonian-using-cirq">
     Define the QAOA cost Hamiltonian using Cirq
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-the-quantum-approximate-optimization-algorithm-to-find-the-ground-state">
   Using the Quantum Approximate Optimization Algorithm to find the ground state
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-the-qaoa-ansatz">
     Defining the QAOA ansatz
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-an-executor-function-to-run-or-simulate-the-experiment">
     Defining an “executor” function to run or simulate the experiment
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#minimization-of-the-qaoa-cost">
     Minimization of the QAOA cost
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#comparing-ideal-noisy-and-mitigated-backends">
   Comparing ideal, noisy and mitigated backends
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ideal-simulation">
     Ideal simulation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-a-noisy-unmitigated-simulator">
     Using a noisy unmitigated simulator
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-a-noisy-simulator-mitigated-with-mitiq">
     Using a noisy simulator mitigated with Mitiq
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
    
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="solving-maxcut-with-mitiq-improved-qaoa">
<h1>Solving MaxCut with Mitiq-improved QAOA<a class="headerlink" href="#solving-maxcut-with-mitiq-improved-qaoa" title="Permalink to this headline">#</a></h1>
<p>In this notebook we solve a simple <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_cut"><em>MaxCut</em> problem</a> with the
<em>Quantum Approximate Optimization Algorithm</em> (QAOA) <a class="reference external" href="#References">[1-5]</a> executed on a simulated noisy backend.
In particular we are interested in investigating how Mitiq can help reduce errors and improve the results.</p>
<div class="section" id="the-maxcut-problem">
<h2>The MaxCut problem<a class="headerlink" href="#the-maxcut-problem" title="Permalink to this headline">#</a></h2>
<p>A <strong>graph</strong> is a mathematical object characterized by a set <span class="math notranslate nohighlight">\(V\)</span> of <strong>vertices (or nodes)</strong> that we can
enumerate with integers <span class="math notranslate nohighlight">\(V=\{0, 1, 2, \dots, n-1\}\)</span> and a set <span class="math notranslate nohighlight">\(E\)</span> of <strong>edges</strong> (pairs of nodes) which can be defined as
<span class="math notranslate nohighlight">\(E=\{(a_1, b_1), (a_2, b_2), ...., (a_m, b_m)\}\)</span>, where <span class="math notranslate nohighlight">\(a_j\neq b_j\)</span> and  <span class="math notranslate nohighlight">\(a_j, b_j \in V\)</span>.</p>
<p><strong>Note:</strong> If we are not interested in isolated nodes (not connected to any edge), the set of edges <span class="math notranslate nohighlight">\(E\)</span> completely
determine the graph <span class="math notranslate nohighlight">\(G=(V, E)\)</span>.</p>
<p>Therefore, in Python, we can represent a graph without isolated nodes as a <strong>list of tuples</strong>, where each
tuple is a <strong>pair of integers</strong>. For example a <strong>square graph</strong> can be expressed as:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Square graph</span>
<span class="n">square_graph</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Given a graph <span class="math notranslate nohighlight">\((V, E)\)</span>, the <strong>MaxCut problem</strong> is to divide the nodes <span class="math notranslate nohighlight">\(V\)</span> into two disjoint subsets
<span class="math notranslate nohighlight">\(V_A\)</span> and <span class="math notranslate nohighlight">\(V_B\)</span>, such that the number of cuts (edges with one vertex in <span class="math notranslate nohighlight">\(V_A\)</span> and one vertex in <span class="math notranslate nohighlight">\(V_B\)</span>) is maximized.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">count_cuts</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">set_a</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">set_b</span><span class="p">:</span> <span class="nb">set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Counts the number of cuts of a graph bipartition.&quot;&quot;&quot;</span>
    <span class="n">num_cuts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_a</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_b</span><span class="p">:</span>
            <span class="n">num_cuts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_b</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_a</span><span class="p">:</span>
            <span class="n">num_cuts</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">num_cuts</span>
</pre></div>
</div>
</div>
</div>
<p>For example, for the square graph previously defined, the maximum number of cuts is <span class="math notranslate nohighlight">\(4\)</span> which can be
achieved by multiple solutions. For example one of the two optimal solutions is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">set_a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="n">set_b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Indeed, in this case, we have a cut for all the edges of <code class="docutils literal notranslate"><span class="pre">square_graph</span></code>, and so their number is maximum.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">count_cuts</span><span class="p">(</span><span class="n">square_graph</span><span class="p">,</span> <span class="n">set_a</span><span class="p">,</span> <span class="n">set_b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<p>An example of a sub-optimal solution is instead:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">set_a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="n">set_b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">count_cuts</span><span class="p">(</span><span class="n">square_graph</span><span class="p">,</span> <span class="n">set_a</span><span class="p">,</span> <span class="n">set_b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<div class="section" id="representing-a-solution-as-bitstring">
<h3>Representing a solution as bitstring<a class="headerlink" href="#representing-a-solution-as-bitstring" title="Permalink to this headline">#</a></h3>
<p>A handy way of representing a candidate solution of the MaxCut problem, is to use a bitstring <span class="math notranslate nohighlight">\(s_n \cdots s_2s_1\)</span>
in which each bit <span class="math notranslate nohighlight">\(s_j\)</span> is associated to the <span class="math notranslate nohighlight">\(j_{\rm th}\)</span> node of the graph. The value of each bit, <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span>,
can be used to represent the corresponding subset, <span class="math notranslate nohighlight">\(V_A\)</span> or <span class="math notranslate nohighlight">\(V_B\)</span>, to which the node belongs.</p>
<p>For example, using a big-endian convention, the previous optimal and sub-optimal solutions can be represented as:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimal_string</span> <span class="o">=</span> <span class="s2">&quot;1010&quot;</span>
<span class="n">sub_optimal_string</span> <span class="o">=</span> <span class="s2">&quot;1110&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>The corresponding function to count the number of graph cuts can be written in the following way wich is very
similar to the quantum cost function that we will define in the next section.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_cuts_from_string</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">bitstring</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Counts the number of cuts of a graph bipartition represented as a (big-endian) bitstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="n">z1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">bitstring</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">z2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">bitstring</span><span class="p">[</span><span class="o">-</span><span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">z2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">cost</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test this function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Test the function</span>
<span class="n">count_cuts_from_string</span><span class="p">(</span><span class="n">square_graph</span><span class="p">,</span> <span class="n">optimal_string</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">count_cuts_from_string</span><span class="p">(</span><span class="n">square_graph</span><span class="p">,</span> <span class="n">sub_optimal_string</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>The MaxCut problem is <strong>NP-hard</strong>. This means that it is computationally very hard (at least as hard
as any NP problem). It is widely suspected that NP-hard problems will never admit a polynomial algorithm
even if we had at disposal an ideal quantum computer.</p>
<p>However, for practical applications, it is often possible to obtain good <strong>approximations</strong> of the
optimal exact solution. In this notebook we are interested in using the <em>Quantum Approximate Optimization
Algorithm</em> (QAOA) to get an approximate solution the MaxCut problem for a given graph.</p>
</div>
</div>
<div class="section" id="embedding-a-maxcut-problem-into-a-physical-hamiltonian">
<h2>Embedding a MaxCut problem into a physical Hamiltonian<a class="headerlink" href="#embedding-a-maxcut-problem-into-a-physical-hamiltonian" title="Permalink to this headline">#</a></h2>
<p>Given a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> with <span class="math notranslate nohighlight">\(n=|V|\)</span> nodes and <span class="math notranslate nohighlight">\(m=|E|\)</span> edges, one can define the following Hamiltonian
acting on a system of <span class="math notranslate nohighlight">\(n\)</span> qubits:</p>
<div class="math notranslate nohighlight">
\[H = \sum_{(i,\, j) \in E}  \frac{1}{2} (1 - Z_i Z_j),\]</div>
<p>where <span class="math notranslate nohighlight">\(Z_k\)</span> is the Pauli-Z operator applied to the qubit <span class="math notranslate nohighlight">\(k\)</span>, such that <span class="math notranslate nohighlight">\(Z_k |0&gt;_k = +|0 \rangle_k\)</span> and
<span class="math notranslate nohighlight">\(Z_k |1&gt;_k = - |1 \rangle_k\)</span>.</p>
<p>Now we can associate each qubit of the system to a vertex of the graph. A potential solution of the MaxCut
problem  (i.e., the partition <span class="math notranslate nohighlight">\((V_A, V_B)\)</span>) can be represented by a quantum product state:</p>
<div class="math notranslate nohighlight">
\[|\psi \rangle = |s_n \rangle \cdots |s_2 \rangle |s_1\rangle, \]</div>
<p>where <span class="math notranslate nohighlight">\(s_j=0\)</span> if <span class="math notranslate nohighlight">\(j \in V_A\)</span>, while <span class="math notranslate nohighlight">\(s_j=1\)</span> if <span class="math notranslate nohighlight">\(j \in V_B\)</span>.</p>
<p>In this case it is easy to check that the corresponding number of cuts is given by the opposite of the
expectation value of the Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \text{number of cuts } =  - \langle \psi | H | \psi \rangle .\]</div>
<p>In this physical picture, the MaxCut problem corresponds to the problem of finding the ground state of <span class="math notranslate nohighlight">\(H\)</span>
and the maximum number of cuts is equal to minus the ground state energy.</p>
<div class="section" id="define-the-qaoa-cost-hamiltonian-using-cirq">
<h3>Define the QAOA cost Hamiltonian using Cirq<a class="headerlink" href="#define-the-qaoa-cost-hamiltonian-using-cirq" title="Permalink to this headline">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">NamedQubit</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">identity_each</span><span class="p">,</span> <span class="n">ZZ</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">qaoa_hamiltonian</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns the cost Hamiltonian associated to the input graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get all the nodes of the graph</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">node</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">})</span>
    <span class="c1"># Initialize the qubits. One for each node.</span>
    <span class="n">qreg</span> <span class="o">=</span> <span class="p">[</span><span class="n">NamedQubit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nn</span><span class="p">))</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="c1"># Define the Hamiltonian as a NumPy array</span>
    <span class="n">np_identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
    <span class="n">zz_terms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">([</span><span class="n">Circuit</span><span class="p">([</span><span class="n">identity_each</span><span class="p">(</span><span class="o">*</span><span class="n">qreg</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="n">j</span><span class="p">])])</span><span class="o">.</span><span class="n">unitary</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">])</span>
    <span class="n">local_terms</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np_identity</span> <span class="o">-</span> <span class="n">zz_term</span><span class="p">)</span> <span class="k">for</span> <span class="n">zz_term</span> <span class="ow">in</span> <span class="n">zz_terms</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">local_terms</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Since it is diagonal in the computational basis, we can get the ground state energy as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">qaoa_hamiltonian</span><span class="p">(</span><span class="n">square_graph</span><span class="p">))</span>
<span class="c1"># Ground state energy</span>
<span class="nb">min</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-4.0
</pre></div>
</div>
</div>
</div>
<p>which, as expected, corresponds to the opposite of the maximum number of cuts of the original graph.</p>
<p>The associated optimal eigenstates are:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">node</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">square_graph</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">})</span>
<span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
<span class="n">optimal_bitstrings</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">:</span><span class="s2">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">eig_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span> <span class="k">if</span> <span class="n">eig_val</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)]</span>
<span class="n">optimal_bitstrings</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;0101&#39;, &#39;1010&#39;]
</pre></div>
</div>
</div>
</div>
<p>Which indeed correspond to the 2 optimal bipartitions of the original MaxCut problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">count_cuts_from_string</span><span class="p">(</span><span class="n">square_graph</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">)</span> <span class="k">for</span> <span class="n">bitstring</span> <span class="ow">in</span> <span class="n">optimal_bitstrings</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[4, 4]
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="using-the-quantum-approximate-optimization-algorithm-to-find-the-ground-state">
<h2>Using the Quantum Approximate Optimization Algorithm to find the ground state<a class="headerlink" href="#using-the-quantum-approximate-optimization-algorithm-to-find-the-ground-state" title="Permalink to this headline">#</a></h2>
<p>The size of the previously introduced Hamiltonian is <span class="math notranslate nohighlight">\(2^n \times 2^n\)</span>. So, when the graph has many nodes,
finding  the eigenvalues and or the eigenstates as we did above becomes exponentially hard.</p>
<p><strong>Is there a way of finding the ground state of a Hamiltonian using a near-term quantum computer?</strong></p>
<p>This is where Quantum Approximate Optimization Algorithm (QAOA)
<a class="reference external" href="https://arxiv.org/abs/1411.4028">[Farhi, Goldstone, Gutmann, arXiv:1411.4028]</a> comes into play.
This method consists of generating a potential solution state through a variational circuit
<span class="math notranslate nohighlight">\(U_{\vec \alpha, \vec \beta}\)</span> which depends on two vectors of <span class="math notranslate nohighlight">\(p\)</span> real parameters
<span class="math notranslate nohighlight">\(\vec \alpha = (\alpha_1, .... \alpha_p)\)</span>, <span class="math notranslate nohighlight">\(\vec \beta= (\beta_1, .... \beta_p)\)</span> and has the following structure:</p>
<div class="math notranslate nohighlight">
\[|\psi(\vec \alpha, \vec \beta) \rangle = U_{\vec \alpha, \vec \beta}|+\rangle ^{\otimes n}
= R_{\alpha_p} W_{\beta_p} \cdots R_{\alpha_1} W_{\beta_1} |+\rangle ^{\otimes n},\]</div>
<p>where <span class="math notranslate nohighlight">\(|+&gt; = (|0\rangle + |1\rangle)/\sqrt{2}\)</span> and</p>
<div class="math notranslate nohighlight">
\[W_{\beta} = e^{i \beta H }, \quad R_{\alpha} = e^{i \alpha \sum_{j=1}^n X_j },\]</div>
<p>corresponding to the time evolution generated by the system Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> and by a mixing Hamiltonian
<span class="math notranslate nohighlight">\(H_{\rm mix}= \sum_j X_j\)</span>, respectively.</p>
<p>After applying the circuit to generate <span class="math notranslate nohighlight">\(|\psi(\vec \alpha, \vec \beta) \rangle\)</span>, one can easily measure
the energy of the final state</p>
<div class="math notranslate nohighlight">
\[E(\vec \alpha, \vec \beta) =  \langle \psi(\vec \alpha, \vec \beta) | H |\psi(\vec \alpha, \vec \beta)\rangle,\]</div>
<p>via simple measurements in the computational basis of the qubits. Repeating this procedure over many
steps and minimizing the <strong>cost function</strong> <span class="math notranslate nohighlight">\(E(\vec \alpha, \vec \beta)\)</span> with respect to the parameters
<span class="math notranslate nohighlight">\(\vec \alpha\)</span> and <span class="math notranslate nohighlight">\(\vec \beta\)</span> one can approximate the ground state of <span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>The maximum number of cuts for the original graph will be given by the opposite of the optimal cost: <span class="math notranslate nohighlight">\(- \min[ E(\vec \alpha, \vec \beta)]\)</span>.</p>
<p>The corresponding state will be a superposition of one or more optimal solution states
<span class="math notranslate nohighlight">\(|s_1 \rangle |s_2 \rangle \cdots |s_n\rangle\)</span> representing optimal bipartitions <span class="math notranslate nohighlight">\((V_A, V_B)\)</span> of the MaxCut problem.</p>
<div class="section" id="defining-the-qaoa-ansatz">
<h3>Defining the QAOA ansatz<a class="headerlink" href="#defining-the-qaoa-ansatz" title="Permalink to this headline">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">H</span><span class="p">,</span> <span class="n">X</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">qaoa_ansatz</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Circuit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generates a QAOA circuit associated to the input graph, for</span>
<span class="sd">    a specific choice of variational parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph: The input graph.</span>
<span class="sd">        params: The variational parameters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The QAOA circuit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the list of unique nodes from the list of edges</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">node</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">})</span>

    <span class="c1"># Initialize the qubits</span>
    <span class="n">qreg</span> <span class="o">=</span> <span class="p">[</span><span class="n">NamedQubit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nn</span><span class="p">))</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>

    <span class="c1"># Define the Hamiltonian evolution (up to an additive and a multiplicative constant)</span>
    <span class="k">def</span> <span class="nf">h_step</span><span class="p">(</span><span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Circuit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Circuit</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Define the mixing evolution (up to an additive and a multiplicative constant)</span>
    <span class="k">def</span> <span class="nf">mix_step</span><span class="p">(</span><span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Circuit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Circuit</span><span class="p">(</span><span class="n">X</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span> <span class="o">**</span> <span class="n">gamma</span> <span class="k">for</span> <span class="n">qq</span> <span class="ow">in</span> <span class="n">qreg</span><span class="p">)</span>

    <span class="c1"># State preparation layer</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">on_each</span><span class="p">(</span><span class="n">qreg</span><span class="p">))</span>

    <span class="c1"># Apply QAOA steps</span>
    <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">betas</span><span class="p">,</span> <span class="n">alphas</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="n">num_steps</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="n">num_steps</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">betas</span><span class="p">,</span> <span class="n">alphas</span><span class="p">):</span>
        <span class="n">circ</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">h_step</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">mix_step</span><span class="p">(</span><span class="n">alpha</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
</div>
</div>
<p>For example, a 2-step QAOA circuit can be generated as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">betas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">betas</span> <span class="o">+</span> <span class="n">alphas</span>
<span class="n">qaoa_ansatz</span><span class="p">(</span><span class="n">square_graph</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="overflow: auto; white-space: pre;">0: ───H───ZZ─────────────────────────ZZ───────X^0.3───ZZ─────────────────────────ZZ───────X^0.4───
          │                          │                │                          │
1: ───H───ZZ^0.1───ZZ────────────────┼────────X^0.3───ZZ^0.2───ZZ────────────────┼────────X^0.4───
                   │                 │                         │                 │
2: ───H────────────ZZ^0.1───ZZ───────┼────────X^0.3────────────ZZ^0.2───ZZ───────┼────────X^0.4───
                            │        │                                  │        │
3: ───H─────────────────────ZZ^0.1───ZZ^0.1───X^0.3─────────────────────ZZ^0.2───ZZ^0.2───X^0.4───</pre></div></div>
</div>
</div>
<div class="section" id="defining-an-executor-function-to-run-or-simulate-the-experiment">
<h3>Defining an “executor” function to run or simulate the experiment<a class="headerlink" href="#defining-an-executor-function-to-run-or-simulate-the-experiment" title="Permalink to this headline">#</a></h3>
<p>QAOA requires the evaluation of quantum expectation values. Therefore, we define a function which inputs
a generic  circuit and returns the expectation value of a generic observable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">depolarize</span><span class="p">,</span> <span class="n">DensityMatrixSimulator</span>

<span class="k">def</span> <span class="nf">executor</span><span class="p">(</span><span class="n">circ</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Simulates a circuit with depolarizing noise at level &#39;noise&#39; and returns the</span>
<span class="sd">    expectation value of the observable &#39;obs&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SIMULATOR</span> <span class="o">=</span> <span class="n">DensityMatrixSimulator</span><span class="p">()</span>
    <span class="c1"># Add the noise</span>
    <span class="n">noisy_circ</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">with_noise</span><span class="p">(</span><span class="n">depolarize</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">noise</span><span class="p">))</span>
    <span class="c1"># Get the final quantum state</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">SIMULATOR</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">noisy_circ</span><span class="p">)</span><span class="o">.</span><span class="n">final_density_matrix</span>
    <span class="c1"># Return the expectation value</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho</span> <span class="o">@</span> <span class="n">obs</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>For example, let us get the expectation value of the cost Hamiltonian (without optimizing the circuit):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">betas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">betas</span> <span class="o">+</span> <span class="n">alphas</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">qaoa_ansatz</span><span class="p">(</span><span class="n">square_graph</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">qaoa_hamiltonian</span><span class="p">(</span><span class="n">square_graph</span><span class="p">)</span>
<span class="n">executor</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1.4574782699346542
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="minimization-of-the-qaoa-cost">
<h3>Minimization of the QAOA cost<a class="headerlink" href="#minimization-of-the-qaoa-cost" title="Permalink to this headline">#</a></h3>
<p>Let us define a function which can be used for running the QAOA optimization.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>


<span class="k">def</span> <span class="nf">minimize_cost</span><span class="p">(</span>
    <span class="n">cost_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">init_params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Minimizes a cost function which depends on an array variational parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        cost_function: The cost function to minimize.</span>
<span class="sd">        init_params: The initial variational parameters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A triple of the minimum cost, the optimal parameters and a list of costs at each iteration steps.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1"># store the optimization trajectory</span>
    <span class="n">traj</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">xk</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">traj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost_function</span><span class="p">(</span><span class="n">xk</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="n">cost_function</span><span class="p">,</span>
        <span class="n">x0</span><span class="o">=</span><span class="n">init_params</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
        <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;disp&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">300</span><span class="p">},</span>
        <span class="c1"># Set tol=0 to enforce a fixed number of iterations.</span>
        <span class="c1"># Comment tol=0 to speedup the notebook execution.</span>
        <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Optimization history&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iteration Step&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Cost&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">traj</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="comparing-ideal-noisy-and-mitigated-backends">
<h2>Comparing ideal, noisy and mitigated backends<a class="headerlink" href="#comparing-ideal-noisy-and-mitigated-backends" title="Permalink to this headline">#</a></h2>
<div class="section" id="ideal-simulation">
<h3>Ideal simulation<a class="headerlink" href="#ideal-simulation" title="Permalink to this headline">#</a></h3>
<p>We focus on the square graph and try to solve the associated QAOA algorithm.
First, we consider the ideal situation of a noiseless backend.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">betas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
<span class="n">gammas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">init_params</span> <span class="o">=</span> <span class="n">betas</span> <span class="o">+</span> <span class="n">gammas</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qaoa_ideal_cost</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Ideal cost function of the QAOA problem without noise.&quot;&quot;&quot;</span>
    <span class="n">qaoa_circuit</span> <span class="o">=</span> <span class="n">qaoa_ansatz</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">qaoa_obs</span> <span class="o">=</span> <span class="n">qaoa_hamiltonian</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">executor</span><span class="p">(</span><span class="n">qaoa_circuit</span><span class="p">,</span> <span class="n">qaoa_obs</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">ideal_opt_cost</span><span class="p">,</span> <span class="n">ideal_opt_params</span><span class="p">,</span> <span class="n">traj</span> <span class="o">=</span> <span class="n">minimize_cost</span><span class="p">(</span><span class="n">qaoa_ideal_cost</span><span class="p">,</span> <span class="n">init_params</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ideal cost: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ideal_opt_cost</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Warning: Maximum number of iterations has been exceeded.
</pre></div>
</div>
<img alt="../_images/maxcut-demo_48_1.png" src="../_images/maxcut-demo_48_1.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Ideal cost:  -4.0
</pre></div>
</div>
</div>
</div>
<p>Since the simulation is exact, we reach the optimal cost associated to (minus) the maximum number of cuts of the graph.</p>
</div>
<div class="section" id="using-a-noisy-unmitigated-simulator">
<h3>Using a noisy unmitigated simulator<a class="headerlink" href="#using-a-noisy-unmitigated-simulator" title="Permalink to this headline">#</a></h3>
<p>We assume to have some depolarizing noise. This means that we need to re-define the QAOA cost function using a noisy executor function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">BASE_NOISE</span> <span class="o">=</span> <span class="mf">0.03</span>
<span class="k">def</span> <span class="nf">qaoa_noisy_cost</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Noisy cost function of the QAOA problem.&quot;&quot;&quot;</span>
    <span class="n">qaoa_circuit</span> <span class="o">=</span> <span class="n">qaoa_ansatz</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">qaoa_obs</span> <span class="o">=</span> <span class="n">qaoa_hamiltonian</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">executor</span><span class="p">(</span><span class="n">qaoa_circuit</span><span class="p">,</span> <span class="n">qaoa_obs</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="n">BASE_NOISE</span><span class="p">)</span>

<span class="n">noisy_opt_cost</span><span class="p">,</span> <span class="n">noisy_opt_params</span><span class="p">,</span> <span class="n">noisy_traj</span> <span class="o">=</span> <span class="n">minimize_cost</span><span class="p">(</span><span class="n">qaoa_noisy_cost</span><span class="p">,</span> <span class="n">init_params</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Warning: Maximum number of iterations has been exceeded.
</pre></div>
</div>
<img alt="../_images/maxcut-demo_51_1.png" src="../_images/maxcut-demo_51_1.png" />
</div>
</div>
<p>Because of noise, the QAOA optimization is not able to converge to the optimal solution.</p>
<p>Indeed the variational parameters optimized with noise do not minimize the ideal cost.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Noisy cost: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">noisy_opt_cost</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ideal cost evaluated at noisy parameters: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">qaoa_ideal_cost</span><span class="p">(</span><span class="n">noisy_opt_params</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ideal cost: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ideal_opt_cost</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noisy cost:  -2.6122
Ideal cost evaluated at noisy parameters:  -3.2278
Ideal cost:  -4.0
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="using-a-noisy-simulator-mitigated-with-mitiq">
<h3>Using a noisy simulator mitigated with Mitiq<a class="headerlink" href="#using-a-noisy-simulator-mitigated-with-mitiq" title="Permalink to this headline">#</a></h3>
<p>Now let’s try to mitigate this noise using Mitiq.</p>
<p>This can be done by simply wrapping the noisy executor into a mitigated executor. We will use global folding and a linear inference (using a <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.LinearFactory" title="mitiq.zne.inference.LinearFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearFactory</span></code></a> object) to implement zero-noise extrapolation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mitiq</span>
<span class="kn">from</span> <span class="nn">mitiq.zne</span> <span class="kn">import</span> <span class="n">mitigate_executor</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="c1"># Choose a noise scaling method</span>
<span class="n">scaling_method</span> <span class="o">=</span> <span class="n">mitiq</span><span class="o">.</span><span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_global</span>

<span class="c1"># Initialize an inference method (i.e. a Mitiq Factory)</span>
<span class="n">inference_factory</span> <span class="o">=</span> <span class="n">mitiq</span><span class="o">.</span><span class="n">zne</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">LinearFactory</span><span class="p">(</span><span class="n">scale_factors</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>

<span class="c1"># Define the cost function</span>
<span class="k">def</span> <span class="nf">qaoa_mitigated_cost</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Cost function of the QAOA problem using error mitigation.&quot;&quot;&quot;</span>
    <span class="n">qaoa_circuit</span> <span class="o">=</span> <span class="n">qaoa_ansatz</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">qaoa_obs</span> <span class="o">=</span> <span class="n">qaoa_hamiltonian</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">noisy_executor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">qaoa_obs</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="n">BASE_NOISE</span><span class="p">)</span>
    <span class="n">mitigated_executor</span> <span class="o">=</span> <span class="n">mitigate_executor</span><span class="p">(</span><span class="n">noisy_executor</span><span class="p">,</span> <span class="n">factory</span><span class="o">=</span><span class="n">inference_factory</span><span class="p">,</span> <span class="n">scale_noise</span><span class="o">=</span><span class="n">scaling_method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mitigated_executor</span><span class="p">(</span><span class="n">qaoa_circuit</span><span class="p">)</span>

<span class="c1"># Minimize the cost function</span>
<span class="n">mitig_opt_cost</span><span class="p">,</span> <span class="n">mitig_opt_params</span><span class="p">,</span> <span class="n">mitig_traj</span> <span class="o">=</span> <span class="n">minimize_cost</span><span class="p">(</span><span class="n">qaoa_mitigated_cost</span><span class="p">,</span> <span class="n">init_params</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Warning: Maximum number of iterations has been exceeded.
</pre></div>
</div>
<img alt="../_images/maxcut-demo_55_1.png" src="../_images/maxcut-demo_55_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mitigated cost: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mitig_opt_cost</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Noisy cost evaluated at noisy parameters: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">noisy_opt_cost</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Noisy cost evaluated at mitigated parameters: &quot;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">qaoa_noisy_cost</span><span class="p">(</span><span class="n">mitig_opt_params</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ideal cost evaluated at noisy parameters: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">qaoa_ideal_cost</span><span class="p">(</span><span class="n">noisy_opt_params</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ideal cost evaluated at mitigated parameters: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">qaoa_ideal_cost</span><span class="p">(</span><span class="n">mitig_opt_params</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ideal cost: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ideal_opt_cost</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mitigated cost:  -3.0967
Noisy cost evaluated at noisy parameters:  -2.6122
Noisy cost evaluated at mitigated parameters:  -2.7841
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Ideal cost evaluated at noisy parameters:  -3.2278
Ideal cost evaluated at mitigated parameters:  -3.9337
Ideal cost:  -4.0
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The results are clearly enhanced by the application of zero-noise extrapolation.
However the execution time is increased too.
The practical advantage of any error mitigation methods always depends on the trade-off between
the accuracy of the results and the execution time.</p>
</div>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h2>
<p>[1] Edward Farhi, Jeffrey Goldstone, Sam Gutmann, <em>A Quantum Approximate Optimization Algorithm</em>, <a class="reference external" href="https://arxiv.org/abs/1411.4028">arXiv:1411.4028</a>, (2014).</p>
<p>[2] <a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_qaoa_maxcut.html">MaxCut tutorial in PennyLane.</a></p>
<p>[3] <a class="reference external" href="https://qiskit.org/documentation/tutorials/optimization/6_examples_max_cut_and_tsp.html">MaxCut tutorial in Qiskit.</a></p>
<p>[4] <a class="reference external" href="https://grove-docs.readthedocs.io/en/latest/qaoa.html">MaxCut tutorial in PyQuil.</a></p>
<p>[5] <a class="reference external" href="https://quantumai.google/cirq/experiments/qaoa/qaoa_maxcut">MaxCut tutorial in Cirq.</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mitiq</span><span class="o">.</span><span class="n">about</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mitiq: A Python toolkit for implementing error mitigation on quantum computers
==============================================================================
Authored by: Mitiq team, 2020 &amp; later (https://github.com/unitaryfund/mitiq)

Mitiq Version:	0.17.0dev

Core Dependencies
-----------------
Cirq Version:	0.14.1
NumPy Version:	1.20.3
SciPy Version:	1.7.3

Optional Dependencies
---------------------
PyQuil Version:	3.0.1
Qiskit Version:	0.36.2
Braket Version:	1.25.0

Python Version:	3.8.12
Platform Info:	Linux (x86_64)
</pre></div>
</div>
</div>
</div>
</div>
</div>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="simple_landscape.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Mitigating the energy landscape of a variational circuit with Mitiq</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="hamiltonians.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Defining Hamiltonians as Linear Combinations of Pauli Strings</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          
    
<!--
    Adds link to GitHub repository as an animated SVG in the top-right corner
    of the documentation.
    
    Source: github-corners https://github.com/tholman/github-corners

    License:
    The MIT License (MIT)

    Copyright (c) 2016 Tim Holman

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation 
    the rights to use, copy, modify, merge, publish, distribute, sublicense, 
    and/or sell copies of the Software, and to permit persons to whom the 
    Software is furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in 
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
    DEALINGS IN THE SOFTWARE.
-->
<a href="https://github.com/unitaryfund/mitiq" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 60; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>



      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020, Tech Team @ Unitary Fund.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>
<!-- This file displays the animated SVG link to the GitHub repository 
in the top right corner -->


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>What additional options are available when using ZNE? &#8212; Mitiq 0.17.0dev documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/styles/pydata-sphinx-theme.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="What happens when I use ZNE?" href="zne-4-low-level.html" />
    <link rel="prev" title="When should I use ZNE?" href="zne-2-use-case.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/mitiq-logo.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../readme.html">
  <a href="https://github.com/unitaryfund/mitiq">
  </a>
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="guide.html">
  Users Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../examples/examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../apidoc.html">
  API-doc
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../toc_contributing.html">
  Contributing
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../changelog.html">
  Changelog
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../zz_bibliography.html">
  References
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="core-concepts.html">
   Core Concepts
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="frontends-backends.html">
     Frontends and Backends
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="executors.html">
     Executors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="observables.html">
     Observables
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="zne.html">
   Zero Noise Extrapolation
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="zne-1-intro.html">
     How do I use ZNE?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zne-2-use-case.html">
     When should I use ZNE?
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     What additional options are available when using ZNE?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zne-4-low-level.html">
     What happens when I use ZNE?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zne-5-theory.html">
     What is the theory behind ZNE?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="pec.html">
   Probabilistic error cancellation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="pec-1-intro.html">
     How do I use PEC?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pec-2-use-case.html">
     When should I use PEC?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pec-3-options.html">
     What additional options are available in PEC?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pec-4-low-level.html">
     What happens when I use PEC?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pec-5-theory.html">
     What is the theory behind PEC?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="cdr.html">
   Clifford Data Regression
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="cdr-1-intro.html">
     How do I use CDR?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cdr-2-use-case.html">
     When should I use CDR?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cdr-3-options.html">
     What additional options are available in CDR?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cdr-4-low-level.html">
     What happens when I use CDR?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cdr-5-theory.html">
     What is the theory behind CDR?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="ddd.html">
   Digital Dynamical Decoupling
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="ddd-1-intro.html">
     How do I use DDD?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ddd-2-use-case.html">
     When should I use DDD?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ddd-3-options.html">
     What additional options are available when using DDD?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ddd-4-low-level.html">
     What happens when I use DDD?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ddd-5-theory.html">
     What is the theory behind DDD?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="error-mitigation.html">
   About Error Mitigation
  </a>
 </li>
</ul>

  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#noise-scaling-functions">
   Noise scaling functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unitary-folding">
     Unitary Folding
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-special-case-of-odd-integer-scale-factors">
       The special case of odd integer scale factors
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-general-case-of-real-scale-factors">
       The general case of real scale factors
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#folding-gates-by-fidelity">
       Folding gates by fidelity
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extrapolation-methods-factory-objects">
   Extrapolation methods: Factory objects
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#running-zne-with-advanced-options">
   Running ZNE with advanced options
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#analysis-of-zne-data">
     Analysis of ZNE data
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
    
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="what-additional-options-are-available-when-using-zne">
<h1>What additional options are available when using ZNE?<a class="headerlink" href="#what-additional-options-are-available-when-using-zne" title="Permalink to this headline">#</a></h1>
<p>In the introductory section <a class="reference internal" href="zne-1-intro.html"><span class="doc std std-doc">How do I use ZNE?</span></a>, we used the function
<code class="xref py py-func docutils literal notranslate"><span class="pre">execute_with_zne()</span></code> to evaluate error-mitigated expectation values with zero-noise extrapolation.
Beyond the positional arguments (<code class="docutils literal notranslate"><span class="pre">circuit</span></code>, <code class="docutils literal notranslate"><span class="pre">executor</span></code> and <code class="docutils literal notranslate"><span class="pre">observable</span></code>) that are common to all
error mitigation techniques, one can use additional keyword arguments for optional settings as shown in next code snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mitiq</span> <span class="kn">import</span> <span class="n">zne</span>

<span class="n">zne_value</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">execute_with_zne</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">,</span>
    <span class="n">executor</span><span class="p">,</span>
    <span class="n">observable</span><span class="p">,</span>
    <span class="n">scale_noise</span> <span class="o">=</span> <span class="o">&lt;</span><span class="s2">&quot;noise scaling method imported from zne.scaling&quot;</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">factory</span> <span class="o">=</span> <span class="o">&lt;</span><span class="s2">&quot;extrapolation Factory imported from zne.inference&quot;</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">num_to_average</span> <span class="o">=</span> <span class="o">&lt;</span><span class="s2">&quot;number of repeated evaluations for each noise-scaled circuit&quot;</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The three main options are <code class="docutils literal notranslate"><span class="pre">scale_noise</span></code>, <code class="docutils literal notranslate"><span class="pre">factory</span></code> and <code class="docutils literal notranslate"><span class="pre">num_to_average</span></code>.</p>
<ul class="simple">
<li><p>The option <code class="docutils literal notranslate"><span class="pre">scale_noise</span></code> can be used to select a noise scaling method.
More details are explained below.</p></li>
<li><p>The option <code class="docutils literal notranslate"><span class="pre">factory</span></code> can be used to select an extrapolation method.
More details are explained below.</p></li>
<li><p>The option <code class="docutils literal notranslate"><span class="pre">num_to_average</span></code> can be used to average over multiple evaluations of each noise-scaled expectation value.</p></li>
</ul>
<p>In the next sections we explain in more details how noise scaling and extrapolation methods are represented in Mitiq
and how they can be applied in practice.</p>
<div class="section" id="noise-scaling-functions">
<h2>Noise scaling functions<a class="headerlink" href="#noise-scaling-functions" title="Permalink to this headline">#</a></h2>
<p>To apply ZNE, we need to effectively increase the noise acting in a quantum computation. Instead of directly controlling the physical backend,
Mitiq achieves this task by <em>digital</em> noise scaling, i.e., with circuit manipulations that indirectly increase the effect of noise but keep the circuit logic unchanged.
More details on digital ZNE can be found in <a class="reference internal" href="zne-5-theory.html"><span class="doc std std-doc">What is the theory behind ZNE?</span></a></p>
<p>In Mitiq a noise scaling method is represented by a <em>noise scaling function</em> that takes as input a <code class="docutils literal notranslate"><span class="pre">circuit</span></code> and a real <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> and
returns a <code class="docutils literal notranslate"><span class="pre">scaled_circuit</span></code>. For a noiseless backend, <code class="docutils literal notranslate"><span class="pre">scaled_circuit</span></code> has the same effect as <code class="docutils literal notranslate"><span class="pre">circuit</span></code>. For a noisy backend,
<code class="docutils literal notranslate"><span class="pre">scaled_circuit</span></code> is more sensitive to errors depending on the magnitude of <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code>.</p>
<div class="section" id="unitary-folding">
<h3>Unitary Folding<a class="headerlink" href="#unitary-folding" title="Permalink to this headline">#</a></h3>
<p>Mitiq provides several noise scaling functions. Most of them are based on the repeated application of the <em>unitary folding</em> technique in
which a unitary <span class="math notranslate nohighlight">\(G\)</span> is mapped as follows:</p>
<div class="math notranslate nohighlight">
\[G \longrightarrow G G^\dagger G.\]</div>
<p>If this is applied to individual gates of a <code class="docutils literal notranslate"><span class="pre">circuit</span></code>, we call it <em>local folding</em>. If <span class="math notranslate nohighlight">\(G\)</span> is the entire <code class="docutils literal notranslate"><span class="pre">circuit</span></code>, we call it <em>global folding</em>.</p>
<p>The Mitiq function for global folding is:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_global" title="mitiq.zne.scaling.folding.fold_global"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_global()</span></code></a>.</p></li>
</ul>
<p>The Mitiq functions for local folding are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_gates_at_random" title="mitiq.zne.scaling.folding.fold_gates_at_random"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_gates_at_random()</span></code></a>;</p></li>
<li><p><a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_gates_from_left" title="mitiq.zne.scaling.folding.fold_gates_from_left"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_gates_from_left()</span></code></a>;</p></li>
<li><p><a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_gates_from_right" title="mitiq.zne.scaling.folding.fold_gates_from_right"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_gates_from_right()</span></code></a>;</p></li>
<li><p><a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_all" title="mitiq.zne.scaling.folding.fold_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_all()</span></code></a>.</p></li>
</ul>
<p>There are multiple functions for local folding since it can be applied to the gates of a circuit according to different orderings:
at random, from left (starting from the initial gates), from right (starting from the final gates), etc..
For more details on folding functions, we suggest to click on the functions listed above and check the associated API docs.</p>
<p>If not specified by the user, the default noise scaling method in Mitiq is <a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_gates_at_random" title="mitiq.zne.scaling.folding.fold_gates_at_random"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_gates_at_random()</span></code></a>.
Custom noise-scaling functions can also be defined by the user, as shown
in <a class="reference internal" href="zne-4-low-level.html"><span class="doc std std-doc">What happens when I use ZNE ?</span></a>.</p>
<p><strong>Note:</strong> <em>All folding functions can be applied to circuits defined in any supported frontend. For example, in the next code cells we use Cirq to represent quantum circuits.</em></p>
<div class="section" id="the-special-case-of-odd-integer-scale-factors">
<h4>The special case of odd integer scale factors<a class="headerlink" href="#the-special-case-of-odd-integer-scale-factors" title="Permalink to this headline">#</a></h4>
<p>For any noise scaling function, if <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> is equal to 1, the input circuit is unchanged
and it is subject to the base noise of the backend.</p>
<p>Both local and global folding, if applied uniformly to all the gates of <code class="docutils literal notranslate"><span class="pre">circuit</span></code>, produce a <code class="docutils literal notranslate"><span class="pre">scaled_circuit</span></code> that has 3 times more gates than the input <code class="docutils literal notranslate"><span class="pre">circuit</span></code>.
This corresponds to the <code class="docutils literal notranslate"><span class="pre">scale_factor=3</span></code> setting. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq</span>
<span class="kn">from</span> <span class="nn">mitiq</span> <span class="kn">import</span> <span class="n">zne</span>

<span class="c1"># Get a circuit to fold</span>
<span class="n">qreg</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">LineQubit</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">cirq</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">cirq</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original circuit:&quot;</span><span class="p">,</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Apply local folding</span>
<span class="n">scaled_circuit</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_gates_at_random</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Locally folded circuit:&quot;</span><span class="p">,</span> <span class="n">scaled_circuit</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Apply global folding</span>
<span class="n">scaled_circuit</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_global</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Globally folded circuit:&quot;</span><span class="p">,</span> <span class="n">scaled_circuit</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Original circuit:
0: ───H───@───
          │
1: ───────X───
Locally folded circuit:
0: ───H───H───H───@───@───@───
                  │   │   │
1: ───────────────X───X───X───
Globally folded circuit:
0: ───H───@───@───H───H───@───
          │   │           │
1: ───────X───X───────────X───
</pre></div>
</div>
</div>
</div>
<p>The same trick can be generalized to any odd integer <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code>.
In this case, folding functions apply the mapping <span class="math notranslate nohighlight">\(G \longrightarrow G (G^\dagger G)^{({\rm scale\_factor} - 1)/2}\)</span>. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_gates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">()))</span>
<span class="k">for</span> <span class="n">scale_factor</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]:</span>
    <span class="n">scaled_circuit</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_global</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>
    <span class="n">scaled_num_gates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">scaled_circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For scale_factor=</span><span class="si">{</span><span class="n">scale_factor</span><span class="si">}</span><span class="s2">, the number of gates was scaled by </span><span class="si">{</span><span class="n">scaled_num_gates</span> <span class="o">/</span> <span class="n">num_gates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>For scale_factor=1, the number of gates was scaled by 1.0
For scale_factor=3, the number of gates was scaled by 3.0
For scale_factor=5, the number of gates was scaled by 5.0
For scale_factor=7, the number of gates was scaled by 7.0
</pre></div>
</div>
</div>
</div>
<p><strong>Note:</strong> <em>When <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> is an odd integer, the number of gates is scaled exactly as dictated by the value of <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code>.
In this case, since all gates are folded the same number of times, the three local folding functions
<a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_gates_at_random" title="mitiq.zne.scaling.folding.fold_gates_at_random"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_gates_at_random()</span></code></a>, <a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_gates_from_left" title="mitiq.zne.scaling.folding.fold_gates_from_left"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_gates_from_left()</span></code></a> and <a class="reference internal" href="../apidoc.html#mitiq.zne.scaling.folding.fold_gates_from_right" title="mitiq.zne.scaling.folding.fold_gates_from_right"><code class="xref py py-func docutils literal notranslate"><span class="pre">fold_gates_from_right()</span></code></a> have the same (deterministic) effect.</em></p>
</div>
<div class="section" id="the-general-case-of-real-scale-factors">
<h4>The general case of real scale factors<a class="headerlink" href="#the-general-case-of-real-scale-factors" title="Permalink to this headline">#</a></h4>
<p>More generally, the <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> can be set to any real number larger than or equal to one. In this case,
Mitiq applies additional folding to a selection of gates (for local folding) or to a final fraction of the circuit (for global folding),
such that the total number of gates is <em>approximately</em> scaled by <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code>. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_gates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">()))</span>
<span class="k">for</span> <span class="n">scale_factor</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]:</span>
    <span class="n">scaled_circuit</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_gates_at_random</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>
    <span class="n">scaled_num_gates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">scaled_circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For scale_factor=</span><span class="si">{</span><span class="n">scale_factor</span><span class="si">}</span><span class="s2">, the number of gates was scaled by </span><span class="si">{</span><span class="n">scaled_num_gates</span> <span class="o">/</span> <span class="n">num_gates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>For scale_factor=1.2, the number of gates was scaled by 1.0
For scale_factor=1.4, the number of gates was scaled by 1.0
For scale_factor=1.6, the number of gates was scaled by 2.0
For scale_factor=1.8, the number of gates was scaled by 2.0
For scale_factor=2.0, the number of gates was scaled by 2.0
</pre></div>
</div>
</div>
</div>
<p><strong>Note:</strong> <em>As printed above, if <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> is not an odd integer and if the input circuit is very short, there can be a large error in the actual scaling of the number of gates.
For this reason, when dealing with very short circuits, we suggest to use odd integer scale factors.</em></p>
<p>For longer circuits, real scale factors are better approximated.
Indeed, when <code class="docutils literal notranslate"><span class="pre">num_gates</span></code> and <code class="docutils literal notranslate"><span class="pre">scaled_num_gates</span></code> are large integers, their ratio
can take values with a more fine-grained resolution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">long_circuit</span> <span class="o">=</span> <span class="n">circuit</span> <span class="o">*</span> <span class="mi">5</span>
<span class="n">num_gates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">long_circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">()))</span>
<span class="k">for</span> <span class="n">scale_factor</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]:</span>
    <span class="n">scaled_circuit</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_gates_at_random</span><span class="p">(</span><span class="n">long_circuit</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>
    <span class="n">scaled_num_gates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">scaled_circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For scale_factor=</span><span class="si">{</span><span class="n">scale_factor</span><span class="si">}</span><span class="s2"> the number of gates was scaled by </span><span class="si">{</span><span class="n">scaled_num_gates</span> <span class="o">/</span> <span class="n">num_gates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>For scale_factor=1.2 the number of gates was scaled by 1.2
For scale_factor=1.4 the number of gates was scaled by 1.4
For scale_factor=1.6 the number of gates was scaled by 1.6
For scale_factor=1.8 the number of gates was scaled by 1.8
For scale_factor=2.0 the number of gates was scaled by 2.0
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="folding-gates-by-fidelity">
<h4>Folding gates by fidelity<a class="headerlink" href="#folding-gates-by-fidelity" title="Permalink to this headline">#</a></h4>
<p>In local folding methods, gates can be folded according to custom fidelities by
passing the keyword argument <code class="docutils literal notranslate"><span class="pre">fidelities</span></code>. This
argument should be a dictionary where each key is a string which specifies the
gate and the value of the key is the fidelity of that gate. An example is shown
below where we set the fidelity of all single qubit gates to be 1.0, meaning that
these gates introduce negligible errors in the computation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define test circuit</span>
<span class="n">qreg</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">LineQubit</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">test_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">((</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">on_each</span><span class="p">(</span><span class="o">*</span><span class="n">qreg</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">TOFFOLI</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">qreg</span><span class="p">)</span>
    
<span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original circuit:&quot;</span><span class="p">,</span> <span class="n">test_circuit</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Fold by fidelities</span>
<span class="n">folded</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_gates_at_random</span><span class="p">(</span>
    <span class="n">test_circuit</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fidelities</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;single&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="mf">0.99</span><span class="p">,</span> <span class="s2">&quot;TOFFOLI&quot;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">},</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Folded circuit:&quot;</span><span class="p">,</span> <span class="n">folded</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Original circuit:
0: ───H───@───@───
          │   │
1: ───H───X───@───
              │
2: ───H───T───X───

Folded circuit:
0: ───H───@───@───@───@───@───@───
          │   │   │   │   │   │
1: ───H───X───X───X───@───@───@───
                      │   │   │
2: ───H───T───────────X───X───X───
</pre></div>
</div>
</div>
</div>
<p>We can see that only the two-qubit gates and three-qubit gates have been folded.</p>
<p>Specific gate keys override the global <code class="docutils literal notranslate"><span class="pre">&quot;single&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;double&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;triple&quot;</span></code> options. For example, the dictionary
<code class="docutils literal notranslate"><span class="pre">fidelities</span> <span class="pre">=</span> <span class="pre">{&quot;single&quot;:</span> <span class="pre">1.0,</span> <span class="pre">&quot;H&quot;:</span> <span class="pre">0.99}</span></code> sets all single qubit gates to fidelity one except the Hadamard gate.</p>
<p>A full list of string keys for gates can be found with <code class="docutils literal notranslate"><span class="pre">help(fold_method)</span></code> where <code class="docutils literal notranslate"><span class="pre">fold_method</span></code> is a valid local
folding method. Fidelity values must be between zero and one.</p>
</div>
</div>
</div>
<div class="section" id="extrapolation-methods-factory-objects">
<h2>Extrapolation methods: Factory objects<a class="headerlink" href="#extrapolation-methods-factory-objects" title="Permalink to this headline">#</a></h2>
<p>Extrapolation methods are represented in Mitiq as <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.Factory" title="mitiq.zne.inference.Factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Factory</span></code></a> objects.
The typical tasks of a <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.Factory" title="mitiq.zne.inference.Factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Factory</span></code></a> are:</p>
<ol class="simple">
<li><p>Record the result of the computation executed at the chosen noise level;</p></li>
<li><p>Determine the noise scale factor at which the next computation should be run;</p></li>
<li><p>Given the history of noise scale factors and results, evaluate the associated zero-noise extrapolation.</p></li>
</ol>
<p>The <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.Factory" title="mitiq.zne.inference.Factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Factory</span></code></a> class has two main abstract subclasses:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.BatchedFactory" title="mitiq.zne.inference.BatchedFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchedFactory</span></code></a> representing non-adaptive extrapolation algorithms in which the noise scale factors are fixed and a batch of noise scaled circuits is measured;</p></li>
<li><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.AdaptiveFactory" title="mitiq.zne.inference.AdaptiveFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaptiveFactory</span></code></a> representing adaptive extrapolation algorithms in which the choice of the next noise scale factor depends on the history of the measured results.</p></li>
</ul>
<p>Specific classes derived from <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.BatchedFactory" title="mitiq.zne.inference.BatchedFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchedFactory</span></code></a> or <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.AdaptiveFactory" title="mitiq.zne.inference.AdaptiveFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaptiveFactory</span></code></a> represent different zero-noise extrapolation
methods.</p>
<p>Mitiq provides a number of built-in factories, which can be found in the module <a class="reference internal" href="../apidoc.html#module-mitiq.zne.inference" title="mitiq.zne.inference"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mitiq.zne.inference</span></code></a> and are summarized in the following table.</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.LinearFactory" title="mitiq.zne.inference.LinearFactory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearFactory</span></code></a></p></td>
<td><p>Factory object implementing zero-noise extrapolation based on a linear fit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.RichardsonFactory" title="mitiq.zne.inference.RichardsonFactory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RichardsonFactory</span></code></a></p></td>
<td><p>Factory object implementing Richardson extrapolation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.PolyFactory" title="mitiq.zne.inference.PolyFactory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolyFactory</span></code></a></p></td>
<td><p>Factory object implementing a zero-noise extrapolation algorithm based on a polynomial fit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.ExpFactory" title="mitiq.zne.inference.ExpFactory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExpFactory</span></code></a></p></td>
<td><p>Factory object implementing a zero-noise extrapolation algorithm assuming an exponential ansatz y(x) = a + b * exp(-c * x), with c &gt; 0.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.PolyExpFactory" title="mitiq.zne.inference.PolyExpFactory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolyExpFactory</span></code></a></p></td>
<td><p>Factory object implementing a zero-noise extrapolation algorithm assuming an (almost) exponential ansatz with a non linear exponent y(x) = a + sign * exp(z(x)), where z(x) is a polynomial of a given order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../apidoc.html#mitiq.zne.inference.AdaExpFactory" title="mitiq.zne.inference.AdaExpFactory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AdaExpFactory</span></code></a></p></td>
<td><p>Factory object implementing an adaptive zero-noise extrapolation algorithm assuming an exponential ansatz y(x) = a + b * exp(-c * x), with c &gt; 0.</p></td>
</tr>
</tbody>
</table>
<p>In Mitiq the default extrapolation method is Richardson extrapolation with scale factors 1, 2 and 3 and corresponding to the following <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.Factory" title="mitiq.zne.inference.Factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Factory</span></code></a> object:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mitiq</span> <span class="kn">import</span> <span class="n">zne</span>

<span class="c1"># Default extrapolation method in Mitiq</span>
<span class="n">richardson_factory</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">RichardsonFactory</span><span class="p">(</span><span class="n">scale_factors</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Different extrapolation methods can be initialized in a similar way. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Linear fit with scale factors 1 and 3</span>
<span class="n">linear_factory</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">LinearFactory</span><span class="p">(</span><span class="n">scale_factors</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="c1"># Polynomial fit of degree 2 with scale factors [1, 1.5, 2, 2.5, 3] .</span>
<span class="n">poly_factory</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">PolyFactory</span><span class="p">(</span><span class="n">scale_factors</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Exponential fit with scale factors [1, 2, 3] assuming an infinite-noise limit of 0.5.</span>
<span class="n">exp_factory</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">ExpFactory</span><span class="p">(</span><span class="n">scale_factors</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">asymptote</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Adaptive exponential fit with 5 scale factors, assuming an infinite-noise limit of 0.5.</span>
<span class="n">adaptive_factory</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">AdaExpFactory</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">asymptote</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Note:</strong> <em>Richardson extrapolation is equivalent to an exact polynomial interpolation.
This means that a <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.RichardsonFactory" title="mitiq.zne.inference.RichardsonFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">RichardsonFactory</span></code></a> object is equivalent to a <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.PolyFactory" title="mitiq.zne.inference.PolyFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyFactory</span></code></a> with <code class="docutils literal notranslate"><span class="pre">order=len(scale_factors)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</em></p>
</div>
<div class="section" id="running-zne-with-advanced-options">
<h2>Running ZNE with advanced options<a class="headerlink" href="#running-zne-with-advanced-options" title="Permalink to this headline">#</a></h2>
<p>To show an example, we define a circuit and an executor as shown in <a class="reference internal" href="zne-1-intro.html"><span class="doc std std-doc">How do I use ZNE?</span></a> but apply ZNE with advanced options.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mitiq</span> <span class="kn">import</span> <span class="n">benchmarks</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">benchmarks</span><span class="o">.</span><span class="n">generate_rb_circuits</span><span class="p">(</span><span class="n">n_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_cliffords</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">circuit</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style="overflow: auto; white-space: pre;">0: ───X─────Y^0───@───X^-0.5───Y^-0.5───X^0.5────Y^0.5───@───X^0─────X^0.5───Y^0──────@───Y^0.5────@───X^-0.5───Y^-0.5───X^0.5───
                  │                                      │                            │            │
1: ───X^0─────────@───Y^0.5────Y^0.5────X^-0.5───────────@───Y^0.5───X───────Y^-0.5───@───X^-0.5───@───Y^-0.5────────────────────</pre></div></div>
</div>
<p>Typically the noise of single-qubit gates is negligible with respect to the noise of two-qubit gates.
To simulate this fact, we define an executor that simulates the effect of depolarizing noise acting on two-qubit gates only.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">DensityMatrixSimulator</span><span class="p">,</span> <span class="n">depolarize</span>
<span class="kn">from</span> <span class="nn">mitiq</span> <span class="kn">import</span> <span class="n">Executor</span>

<span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">noise_level</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns Tr[ρ |0⟩⟨0|] where ρ is the state prepared by the circuit</span>
<span class="sd">    executed with depolarizing noise acting on two-qubit gates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Replace with code based on your frontend and backend.</span>
    <span class="n">noisy_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">all_operations</span><span class="p">():</span>
        <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="c1"># Add depolarizing noise after two-qubit gates</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">depolarize</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">noise_level</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="mi">2</span><span class="p">)(</span><span class="o">*</span><span class="n">op</span><span class="o">.</span><span class="n">qubits</span><span class="p">))</span>

    <span class="n">rho</span> <span class="o">=</span> <span class="n">DensityMatrixSimulator</span><span class="p">()</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">noisy_circuit</span><span class="p">)</span><span class="o">.</span><span class="n">final_density_matrix</span>
    <span class="k">return</span> <span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>

<span class="n">executor</span> <span class="o">=</span> <span class="n">Executor</span><span class="p">(</span><span class="n">execute</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the next code cell we run ZNE with several advanced options:</p>
<ul class="simple">
<li><p>We seed the noise scaling function;</p></li>
<li><p>We fold only CNOT gates using the <code class="docutils literal notranslate"><span class="pre">fidelity</span></code> option;</p></li>
<li><p>We use a non-default extrapolation method (<a class="reference internal" href="../apidoc.html#mitiq.zne.inference.ExpFactory" title="mitiq.zne.inference.ExpFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpFactory</span></code></a>).</p></li>
</ul>
<p><strong>Note:</strong> <em>The scope of the next code cell is not to define an optimal ZNE estimation, but to show a large number of options.</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Random local folding applied to two-qubit gates with a seeded random state </span>
<span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">noise_scaling_function</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">zne</span><span class="o">.</span><span class="n">scaling</span><span class="o">.</span><span class="n">fold_gates_at_random</span><span class="p">,</span>
    <span class="n">fidelities</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;single&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span>  <span class="c1"># Avoid folding single-qubit gates</span>
    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>  <span class="c1"># Useful to get reproducible results</span>
<span class="p">)</span>
<span class="c1"># Exponential fit with scale factors [1, 2, 3], assuming an infinite-noise limit of 0.5.</span>
<span class="n">factory</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">inference</span><span class="o">.</span><span class="n">ExpFactory</span><span class="p">(</span><span class="n">scale_factors</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">asymptote</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>

<span class="n">zne_value</span> <span class="o">=</span> <span class="n">zne</span><span class="o">.</span><span class="n">execute_with_zne</span><span class="p">(</span>
    <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">,</span>
    <span class="n">executor</span><span class="o">=</span><span class="n">executor</span><span class="p">,</span>
    <span class="n">observable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">factory</span><span class="o">=</span><span class="n">factory</span><span class="p">,</span>
    <span class="n">scale_noise</span><span class="o">=</span><span class="n">noise_scaling_function</span><span class="p">,</span>
    <span class="n">num_to_average</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">zne_value</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.999999576901606
</pre></div>
</div>
</div>
</div>
<div class="section" id="analysis-of-zne-data">
<h3>Analysis of ZNE data<a class="headerlink" href="#analysis-of-zne-data" title="Permalink to this headline">#</a></h3>
<p>Since we defined a <code class="docutils literal notranslate"><span class="pre">factory</span></code> with 3 scale factors and since <code class="docutils literal notranslate"><span class="pre">num_to_average=3</span></code>, we expect <span class="math notranslate nohighlight">\(3 \times 3=9\)</span> circuit evaluations. Indeed:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">executor</span><span class="o">.</span><span class="n">calls_to_executor</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9
</pre></div>
</div>
</div>
</div>
<p>The corresonding noisy results are:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">executor</span><span class="o">.</span><span class="n">quantum_results</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.7276562,
 0.7276562,
 0.7276562,
 0.5542075,
 0.55420744,
 0.55420756,
 0.44374222,
 0.44374222,
 0.44374222]
</pre></div>
</div>
</div>
</div>
<p>The noise scaled expectation values (averaged over <code class="docutils literal notranslate"><span class="pre">num_to_average=3</span></code> raw results) are:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">factory</span><span class="o">.</span><span class="n">get_expectation_values</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.7276562, 0.5542075, 0.4437422], dtype=float32)
</pre></div>
</div>
</div>
</div>
<p>We can also visualize the extrapolation fit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">plot_fit</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/zne-3-options_42_0.png" src="../_images/zne-3-options_42_0.png" />
</div>
</div>
<p>In this section we have shown how to run ZNE with non-default options.
A lower-level usage of noise scaling methods and <a class="reference internal" href="../apidoc.html#mitiq.zne.inference.Factory" title="mitiq.zne.inference.Factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Factory</span></code></a> objects is presented the next section (<a class="reference internal" href="zne-4-low-level.html"><span class="doc std std-doc">What happens when I use ZNE?</span></a>).</p>
</div>
</div>
</div>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="zne-2-use-case.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">When should I use ZNE?</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="zne-4-low-level.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">What happens when I use ZNE?</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          
    
<!--
    Adds link to GitHub repository as an animated SVG in the top-right corner
    of the documentation.
    
    Source: github-corners https://github.com/tholman/github-corners

    License:
    The MIT License (MIT)

    Copyright (c) 2016 Tim Holman

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation 
    the rights to use, copy, modify, merge, publish, distribute, sublicense, 
    and/or sell copies of the Software, and to permit persons to whom the 
    Software is furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in 
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
    DEALINGS IN THE SOFTWARE.
-->
<a href="https://github.com/unitaryfund/mitiq" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 60; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>



      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020, Tech Team @ Unitary Fund.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>